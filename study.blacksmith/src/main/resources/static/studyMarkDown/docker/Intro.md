# ?? ?? ??
1. ????? ???? ??? ???? ??? ??.
2. ????? ??, ?????, ???? ? ??? ??, ?????? ??? ??

# 도커사용 흐름
1. 도커 Client (CLI)에 커맨드 입력
2. 도커 Server (DAEMON)에서 커맨드를 받아 이미지를 생성하거나 컨테이너를 실행한다.
3. 예시
    1. 클라이언트에서 docker run hello-world 입력
    2. 서버에서 hello-world 이미지가 로컬 캐시 보관장소에 있는지 확인
    3. 위에서 없으면, 도커허브에서 확인, pulling

# 도커 vs 기존 가상화기술
1. 가상화 기술 나오기 전
    1. 하나의 서버를 하나의 용도로만 사용하고, 하나의 운영체제, 하나의 프로그램만을 운영, 안정적이지만 비효율
2. 하이퍼바이저 기반의 가상화 출현:
    1. 독립적 가상환경 서버 이용가능, 하이퍼바이저는 호스트시스템에서 다수의 게스트 OS를 구동할 수 있기 함.
       하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링하는 중간관리자.
    2. 네이티브하이퍼바이저: 하이퍼바이저가 직접 하드웨어 제어. 별도 호스트 OS가 없어서 오버헤드 적으나, 여러 하드웨어 드라이버를 세팅해야 한다
    3. 호스트형하이버파이저: 일반 SW처럼 호스트OS위에서 실행되며 하드웨어 자원을 VM내부 게스트 OS에 에뮬레이트 하는 방식. 오버헤드 크지만 게스트 OS종류 제약이 없다.
3. 하이퍼바이저의 역할을 도커엔진이 한다고 보면 된다.
    - 인프라 하드웨어 > 호스트 OS > 도커 > {컨테1, 컨테2, 컨테3}
    - 인프라 하드웨어 > 호스트 OS > 하이퍼바이저 > {VM1, VM2, VM3}
4. 공통점: 도커컨테이너와 가상머신 둘 다 기본하드웨어에서 격리된 환경에 어플리케이션을 배치한다.
5. 차이점
    1. 컨테이너는 게스트 OS가 필요하지 않아서 가볍다. (5-100MB 정도로 가벼움)
    2. 어플리케이션 실행할 떄 컨테이너방식은 호스트OS위에 실행패키지인 이미지를 배포하기만 하면된다.
       VM은 어플리케이션 실행을 위해 VM을 띄우고 자원을 할당한 다음, 게스트 OS를 부팅해 어플리케이션 실행, 무거움
    3. 도커컨테이너: 컨테이너 격리가 되어 있어서 여전히 같은 호스트의 다른 컨테이너와 "동일한 커널을 공유", 그러므로 컨테이너 내부에서 실행되는 프로세스는 호스트시스템에서 볼 수 있다. 하지만 VM은 호스트OS와 완전 독립됨.

# 이미지의 기본요소 (명령어 + 파일스냅샷)
1. 시작시 실행될 명령어 : run kakaotalk
2. 파일 스냅샷 : 카카오톡 파일

# 도커 이미지
1. 컨테이너를 만들기 위해 필요한 설정이나 종속성들을 갖고 있는 소프트웨어 패키지
2. 도커 이미지는 Dockerhub에 이미 다른 사람들이 만들어 놓은 것을 이용할 수 있으며, 직접만들어 사용하거나 Dockerhub에 업로드 할 수도 있다.
3. 도커 이미지를 통해 도커 컨테이너를 생성한다
   docker create <이미지이름>
4. 도커이미지(파일스냅샷 + 명령어)는 어떻게 생성하나
   1. 도커 파일 작성 : 도커이미지를 만들기 위한 설정파일. 컨테이너가 어떻게 행동해야하는지 설정을 정의해준다.
      1. 파일스냅샷인 "베이스이미지"를 명시해준다 (파일스냅샷에 해당) > FROM
         1. <이미지이름><태그>형식으로 작성, 태그 안붙이면 자동으로 최신 다운
      2. 추가 필요한 파일을 다운받기 위한 몇가지 명령어를 명시해준다. (파일스냅샷에 해당) > RUN
         1. 도커이미지가 생성되기 전 수행할 쉘 명령어
      3. 컨테이너 시작시 실행될 명령어를 명시해준다.(시작시 실행 될 명령어에 해당) > CMD
         1. 해당명령어는 DockerFile 내 1회만 쓸 수 있다.
      * 베이스이미지
        1) 여러개의 레이어로 되어 있다. 요소를 추가할 때마다 레이어가 추가된다
        2) 그 중 가장 기본이 되는 레이어가 베이스 이미지(OS라고 생각하면 된다. Window, MacOS, Linux 등)
   2. 도커 클라이언트 : 도커파일에 입력된 것들이 클라이언트에 전달되어야 한다.
      1. docker build ./  또는 docker build .
      2. 위의 빌드명령어를 통해 해당 디렉토리 내 dockerfile을 찾아 도커 클라이언트에 전달한다.
   3. 도커 서버 : 도커 클라이언트에 전달된 작업이 진행되는 곳
   4. 이미지 생성
      1. docker build ./
      2. 이름 짓기 -t smk/hello:latest   docker build -t kdstheace/hello:latest ./
         * -t 내도커아이디 / 저장소/프로젝트이름 : 버전
   
  * 이미지를 만들 때에는 <도커파일> 기반으로 <임시 컨테이너>를 만들었다가 이를 토대로 <이미지>를 생성하고 임시컨테이너를 지운다.

# 이미지로 컨테이너 만드는 순서
   1. docker(클라이언트) run(컨테이너 생성, 실행) image-name(이미지) ls(원래 가진 시작명령어를 무시하고 이 자리의 커맨드를 실행함)
   2. 

# 도커 라이프 사이클
   0. 도커 생명주기
      1. 생성, 시작, 중지, 삭제
      2. 생성 : docker create 이미지이름
      3. 시작 : docker start 시작컨테이너이름
         docker start -a 시작컨이름 : attach가 붙으면 아웃풋도 표시된다.
      4. 생성시작: docker run 이미지이름
         1. -it 아웃풋을 보고 싶을 때 사용, 보통 같이 다닌다.
      5. 중지 : docker stop 중지컨테이너이름/아이디
      6. 삭제 : docker rm 삭제할컨테이너이름/아이디
   실행 > 중지 > 삭제
   1. 중지
      1. docker stop: gracefully stop, 그동안 하던 작업들을 완료하고 컨테이너 중지
         1. docker stop > SIGTERM > (GracePeriod) > SIGKILL > Container(MainProcess)
      2. docker kill: instantly stop, 아무것도 안기다리고 바로 컨테이너 중지
         1. docker stop >                           SIGKILL > Container(MainProcess)
   2. 삭제
      1. 컨테이너 삭제
         1. docker rm <아이디/이름>
         2. docker rm `docker ps -a -q`  -전체삭제
            * 윈도우 : 
            * docker ps -aq | foreach{docker stop $_} - 전체 중지
            * docker ps -aq | foreach {docker rm $_} - 전체 삭제
            * FOR /f "tokens=*" %%i IN ('docker ps -aq') DO docker rm %%i
              FOR /f "tokens=*" %%i IN ('docker images --format "{{.ID}}"') DO docker rmi %%i
      2. 이미지 삭제
         1. docker rmi <이미지id>
         2. docker system prune : 한번에 컨테이너, 이미지, 네트워크 모두 삭제 * 이것도 실행중인 컨테이너에는 영향 X
# 실행 중인 컨테이너에 명령어 전달
   1. docker exec <컨테이너아이디>
      * docker run <컨테이너아이디> 생성하면서 명령어 실행
   2. docker exec -it 컨테이너아이디 명령어
   3. 아예 해당 컨테이너의 쉘환경으로 들어가기
      1. docker exec -it 컨테이너아이디 sh(bash-우분투, zsh, powershell)
      2. /# 뒤에 touch newfile, ls, 다 해보자
      * 환경변수 설정
        1. export hello=hi
        2. echo $hello
   4. 빠져나오기 : ctrl + d

# 레디스 도커 환경에서 실행
1. docker run redis - 서버실행
2. redis-cli - (다른 터미널)클라이언트 실행
   가 아닌, 컨테이너 안에서 실행하기 위해, docker exec -it <컨테이너아이디> redis-cli
3. -it : 붙여줘야 명령어를 실행한 후 계속 명령어를 적을 수 있다. 
   interactive terminal. 안하면 클라이언트 실행만 하고 바로 컨테이너 밖으로 나와버림


# 실제 NodeApp 만들기
1. NodeJs App 만들기 = server.js로 패키징하고 , express 디펜던시 추가
2. Dockerfile 만들기
   1. FROM node:10
      1. alpine으로 하면 npm이 없기 때문에, 뒤에 오는 RUN npm install을 할 수가 없게된다.
   2. RUN npm install
      1. NodeJS로 Npm registry에서 dependencies들을 (eg.express모듈) 가져오기 위함
   3. CMD ["node", "server.js"]
      1. node 웹 서버를 시작할 떄 node + 엔트리포인트 라는 명령어를 입력한다.
   4. COPY
      1. node 베이스 이미지의 컨테이너 안에는 Package.json이 없음
      2. Server.js도 없음
   5. WORKDIR /usr/src/app
      1. 이미지 안에 어플리케이션 소스코드를 갖고 있을 디렉토리를 생성. 이 디렉토리가 워킹디렉토리가 된다.
      2. 왜 필요한가? 
3. docker build -t 이미지이름 ./
4. docker run -p 49160:8080 이미지이름
   1. -p: 로컬네트워크에 있던 것을 컨테이너 내부의 네트웤과 연결시켜줘야 한다.
   2. 포트매핑이 필요. 브라우저의 포트와 컨테이너 내부 포트
5. 종속성 부분만 따로 COPY빼주는 이유: 빌드에서 종속성이 변경되는 경우가 거의 없는데, 소스코드와 같이 COPY를 하면 매번 종속성까지 다시 인스톨을 하기 때문에,
   나눠두면 종속성은 캐시에서 로드하고 소스코드만 업데이트 한다.
6. Docker Volume이란?
   1. 그동안 Copy를 사용해 도커 컨테이너에 복사해줬음. 
   2. node-module이 호스트 디렉토리에 없기 때문에, 컨테이너에 매핑을 하지 말라고 하는 것.
   3. pwd경로에 있는 디렉토리, 파일을 /usr/src/app에서 참조

# Docker Compose
다중 컨테이너
# 명령어
1. 이미지 실행 : docker run hello-world

