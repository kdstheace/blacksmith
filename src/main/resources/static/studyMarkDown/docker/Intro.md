# ?? ?? ??
1. ????? ???? ??? ???? ??? ??.
2. ????? ??, ?????, ???? ? ??? ??, ?????? ??? ??

# 도커 이미지
1. 컨테이너를 만들기 위해 필요한 설정이나 종속성들을 갖고 있는 소프트웨어 패키지
2. 도커 이미지는 Dockerhub에 이미 다른 사람들이 만들어 놓은 것을 이용할 수 있으며, 직접만들어 사용하거나 Dockerhub에 업로드 할 수도 있다.
3. 도커 이미지를 통해 도커 컨테이너를 생성한다
   docker create <이미지이름>
4. 도커이미지는 어떻게 생성하나
   1. 도커 파일 작성 : 도커이미지를 만들기 위한 설정파일. 컨테이너가 어떻게 행동해야하는지 설정을 정의해준다.
   2. 도커 클라이언트 : 도커파일에 입력된 것들이 클라이언트에 전달되어야 한다.
   3. 도커 서버 : 도커 클라이언트에 전달된 작업이 진행되는 곳
   4. 이미지 생성 :


5. ????? ??? ??????? ? ?? ???, ??/??? ? ??? ??? ??.
6. ???? ??? ???? ??? ???
7. ????: ?? ????, ????? ????? ????? ??? ?????? ???. ????? ??/??? ???? ??.
   AWS Azure GoogleCloud?? ??? ??? ? ??? ??.
8. ???????: ??????? ????? ??? ???(??, ????)? ???? ????? ???. ???? ?? ?? ????? ????.
   ????? ???? ??????.

# 도커사용 흐름
1. 도커 Client (CLI)에 커맨드 입력
2. 도커 Server (DAEMON)에서 커맨드를 받아 이미지를 생성하거나 컨테이너를 실행한다.
3. 예시 
   1. 클라이언트에서 docker run hello-world 입력
   2. 서버에서 hello-world 이미지가 로컬 캐시 보관장소에 있는지 확인
   3. 위에서 없으면, 도커허브에서 확인, pulling

# 도커 vs 기존 가상화기술
1. 가상화 기술 나오기 전
   1. 하나의 서버를 하나의 용도로만 사용하고, 하나의 운영체제, 하나의 프로그램만을 운영, 안정적이지만 비효율
2. 하이퍼바이저 기반의 가상화 출현: 
   1. 독립적 가상환경 서버 이용가능, 하이퍼바이저는 호스트시스템에서 다수의 게스트 OS를 구동할 수 있기 함.
      하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링하는 중간관리자.
   2. 네이티브하이퍼바이저: 하이퍼바이저가 직접 하드웨어 제어. 별도 호스트 OS가 없어서 오버헤드 적으나, 여러 하드웨어 드라이버를 세팅해야 한다
   3. 호스트형하이버파이저: 일반 SW처럼 호스트OS위에서 실행되며 하드웨어 자원을 VM내부 게스트 OS에 에뮬레이트 하는 방식. 오버헤드 크지만 게스트 OS종류 제약이 없다.
3. 하이퍼바이저의 역할을 도커엔진이 한다고 보면 된다.
   - 인프라 하드웨어 > 호스트 OS > 도커 > {컨테1, 컨테2, 컨테3}
   - 인프라 하드웨어 > 호스트 OS > 하이퍼바이저 > {VM1, VM2, VM3}
4. 공통점: 도커컨테이너와 가상머신 둘 다 기본하드웨어에서 격리된 환경에 어플리케이션을 배치한다.
5. 차이점
   1. 컨테이너는 게스트 OS가 필요하지 않아서 가볍다. (5-100MB 정도로 가벼움)
   2. 어플리케이션 실행할 떄 컨테이너방식은 호스트OS위에 실행패키지인 이미지를 배포하기만 하면된다. 
      VM은 어플리케이션 실행을 위해 VM을 띄우고 자원을 할당한 다음, 게스트 OS를 부팅해 어플리케이션 실행, 무거움
   3. 도커컨테이너: 컨테이너 격리가 되어 있어서 여전히 같은 호스트의 다른 컨테이너와 "동일한 커널을 공유", 그러므로 컨테이너 내부에서 실행되는 프로세스는 호스트시스템에서 볼 수 있다. 하지만 VM은 호스트OS와 완전 독립됨.
 
# 이미지의 기본요소
   1. 시작시 실행될 명령어 : run kakaotalk
   2. 파일 스냅샷 : 카카오톡 파일

# 이미지로 컨테이너 만드는 순서
   1. docker(클라이언트) run(컨테이너 생성, 실행) image-name(이미지) ls(원래 가진 시작명령어를 무시하고 이 자리의 커맨드를 실행함)
   2. 

# 도커 라이프 사이클
   0. 도커 생명주기
      1. 생성, 시작, 중지, 삭제
      2. 생성 : docker create 이미지이름
      3. 시작 : docker start 시작컨테이너이름
         docker start -a 시작컨이름 : attach가 붙으면 아웃풋도 표시된다.
      4. 생성시작: docker run 이미지이름
      5. 중지 : docker stop 중지컨테이너이름/아이디
      6. 삭제 : docker rm 삭제할컨테이너이름/아이디
   실행 > 중지 > 삭제
   1. 중지
      1. docker stop: gracefully stop, 그동안 하던 작업들을 완료하고 컨테이너 중지
         1. docker stop > SIGTERM > (GracePeriod) > SIGKILL > Container(MainProcess)
      2. docker kill: instantly stop, 아무것도 안기다리고 바로 컨테이너 중지
         1. docker stop >                           SIGKILL > Container(MainProcess)
   2. 삭제
      1. 컨테이너 삭제
         1. docker rm <아이디/이름>
         2. docker rm `docker ps -a -q`  -전체삭제
            * 윈도우 : 
            * docker ps -aq | foreach{docker stop $_} - 전체 중지
            * docker ps -aq | foreach {docker rm $_} - 전체 삭제
            * FOR /f "tokens=*" %%i IN ('docker ps -aq') DO docker rm %%i
              FOR /f "tokens=*" %%i IN ('docker images --format "{{.ID}}"') DO docker rmi %%i
      2. 이미지 삭제
         1. docker rmi <이미지id>
         2. docker system prune : 한번에 컨테이너, 이미지, 네트워크 모두 삭제 * 이것도 실행중인 컨테이너에는 영향 X
# 실행 중인 컨테이너에 명령어 전달
   1. docker exec <컨테이너아이디>
      * docker run <컨테이너아이디> 생성하면서 명령어 실행
   2. docker exec -it 컨테이너아이디 명령어
   3. 아예 해당 컨테이너의 쉘환경으로 들어가기
      1. docker exec -it 컨테이너아이디 sh(bash-우분투, zsh, powershell)
      2. /# 뒤에 touch newfile, ls, 다 해보자
      * 환경변수 설정
        1. export hello=hi
        2. echo $hello
   4. 빠져나오기 : ctrl + d

# 레디스 도커 환경에서 실행
1. docker run redis - 서버실행
2. redis-cli - (다른 터미널)클라이언트 실행
   가 아닌, 컨테이너 안에서 실행하기 위해, docker exec -it <컨테이너아이디> redis-cli
3. -it : 붙여줘야 명령어를 실행한 후 계속 명령어를 적을 수 있다. 
   interactive terminal. 안하면 클라이언트 실행만 하고 바로 컨테이너 밖으로 나와버림


   
# 명령어
1. 이미지 실행 : docker run hello-world